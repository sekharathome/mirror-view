<!DOCTYPE html>
<html>
<head>
    <title>SystemSync Viewer</title>
    <style>
        body { background: #000; color: #fff; text-align: center; font-family: sans-serif; }
        .container { margin: 20px auto; width: 320px; height: 568px; border: 5px solid #222; border-radius: 10px; overflow: hidden; background: #111; }
        canvas { width: 100%; height: 100%; }
        .btns { margin-top: 20px; }
        button { padding: 10px 30px; margin: 5px; font-weight: bold; cursor: pointer; border-radius: 5px; border: none; }
        #start { background: #28a745; color: white; }
        #stop { background: #dc3545; color: white; }
        #snap { background: #007bff; color: white; }
        button:disabled { background: #444; cursor: not-allowed; }
    </style>
</head>
<body>
    <h2>SystemSync Mirror</h2>
    <div id="status">Status: Offline</div>
    <div class="container">
        <canvas id="canvas" width="720" height="1280"></canvas>
    </div>
    <div class="btns">
        <button id="start">START VIEWING</button>
        <button id="stop" disabled>STOP</button>
        <button id="snap">SNAPSHOT</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const snapBtn = document.getElementById('snap');
        
        const SERVER_URL = "wss://mirror-view.onrender.com"; 

        let ws = null;
        let decoder = null;
        let waitingForKeyframe = true; // NEW: Prevents the DataError

        startBtn.onclick = async () => {
            status.innerText = "Status: Connecting...";
            startBtn.disabled = true;
            stopBtn.disabled = false;
            waitingForKeyframe = true; 

            decoder = new VideoDecoder({
                output: f => { 
                    ctx.drawImage(f, 0, 0); 
                    f.close(); 
                },
                error: e => {
                    console.error("Decoder Error:", e);
                    // If we hit an error, reset to wait for a new keyframe
                    waitingForKeyframe = true;
                }
            });

            await decoder.configure({ 
                codec: 'avc1.42E01E', 
                codedWidth: 720, 
                codedHeight: 1280,
                optimizeForLatency: true 
            });

            ws = new WebSocket(SERVER_URL);
            ws.binaryType = 'arraybuffer';

            ws.onmessage = (e) => {
                // Keyframes are significantly larger than delta frames
                const isKey = e.data.byteLength > 10000; 
                
                if (waitingForKeyframe) {
                    if (isKey) {
                        waitingForKeyframe = false;
                        console.log("Keyframe received! Starting stream...");
                    } else {
                        // Skip this frame, we can't use it yet
                        return; 
                    }
                }

                if (decoder.state === "configured") {
                    try {
                        decoder.decode(new EncodedVideoChunk({
                            type: isKey ? 'key' : 'delta',
                            timestamp: performance.now(),
                            data: e.data
                        }));
                    } catch (err) {
                        console.warn("Decode error, resetting sync...");
                        waitingForKeyframe = true;
                    }
                }
            };

            ws.onopen = () => status.innerText = "Status: Live (Waiting for first frame...)";
            ws.onclose = () => {
                status.innerText = "Status: Offline";
                startBtn.disabled = false;
                stopBtn.disabled = true;
            };
        };

        stopBtn.onclick = () => {
            if(ws) ws.close();
            if(decoder) decoder.close();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

        // Snapshot Functionality
        snapBtn.onclick = () => {
            const link = document.createElement('a');
            link.download = 'systemsync-snapshot.png';
            link.href = canvas.toDataURL();
            link.click();
        };
    </script>
</body>
</html>
